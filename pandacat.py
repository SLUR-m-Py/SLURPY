#!/usr/bin/env python
"""
Â© 2023. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy/National Nuclear Security Administration. 
All rights in the program are reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear Security Administration. 
The Government is granted for itself and others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare derivative works, distribute copies to the public, perform publicly and display publicly, and to permit others to do so.
"""
## --------------------------- v 1.0.0 ---------------------------- ## 
##   PANDA CAT (Concatonate pandas dataframe in python) 
## ---------------------------------------------------------------- ##
"""
Written by:

Cullen Roth, Ph.D.

Postdoctoral Research Associate
Genomics and Bioanalytics (B-GEN)
Los Alamos National Laboratory
Los Alamos, NM 87545
croth@lanl.gov
"""
## -------------------------------------------------- MOD LOADING ----------------------------------------------- ## 
## Bring in file size
from os.path import getsize, exists
## Load in reset ftn 
from defaults import reset, slurpydir
## Bring in hutil
import shutil

## Ftn for calling pandacat for concatonating
def pandacat(infiles:list, outfile:str, report:str, rmheader=False, sortpaths=False) -> tuple:
    """Formats a command to merge hic file from pandas dataframe."""
    ## Set the skip head and soritng flags
    skiphead = ' --skipheader ' if rmheader else ''
    sorting  = ' --sort ' if sortpaths else ''
    ## Return the formated commands
    return [f'{slurpydir}/pandacat.py -i {' '.join(infiles)} -o {outfile}{skiphead}{sorting}\n']#, f'{scriptsdir}/myecho.py Finished concatenating files into file: {outfile} {report}\n']

## Set the script sescription
pandadesc = "Concatonates a series of input pandas dataframes as text files (ingnoring header on all but first)."

## Set help message
i_help = "Input wild card path (or paths) to csv,txt, or bedpe files to be combined."
o_help = "Output path of combined file generated by this script."
R_help = "Boolean flag to skipper header of file in all but first file."
B_help = "Boolean flag to sort the input file names from  a wild card."

## ------------------------------------------------------ BODY of MAIN EXECUTABLE --------------------------------------------------------- ##
## If the script is called 
if __name__ == "__main__":
    ## Bring in argparse and set parser
    import argparse

    ## Make the parse
    parser = argparse.ArgumentParser(description = pandadesc)
    ## Add the required arguments
    parser.add_argument("-i", dest="I", nargs='+', required=True,  help=i_help, metavar='./path/to/input.txt')
    parser.add_argument("-o", dest="O", type=str,  required=True,  help=o_help, metavar="./path/to/combined.out.txt")
    ## Add boolean vars
    parser.add_argument("--skipheader", dest="R",  help = R_help,  action = 'store_true')
    parser.add_argument("--sort",       dest="S",  help = B_help,  action = 'store_true')

    ## Set the paresed values as inputs
    inputs = parser.parse_args()

    ## Set inputs 
    inpaths      = inputs.I     ## Input text files 
    outputfile   = inputs.O     ## Output files
    removeheader = inputs.R     ## Removeing the header
    sorting      = inputs.S     ## Flag to sort 

    ## Make sure we have files
    assert len(inpaths), "ERROR: No files were passed. Failed to generate %s!"%outputfile

    ## Modify the input paths for backwards compatibality, make sure only a str was passed with wild-card symbole in it. 
    if (len(inpaths) == 1) and ('*' in inpaths[0]):
        ## Bring in glob from glob 
        from glob import glob 
        ## bring in paths 
        inpaths = glob(inpaths[0])
        ## Check our paths
        assert len(inpaths), "ERROR: No files could be gathered with input wildcard: %s"%inpaths[0]

    ## Sort the input files 
    inpaths = sorted(inpaths) if sorting else inpaths

    ## Remove the previous output file it is exists
    k = reset([outputfile])

    ## Open the output file for wiritng (only once?)
    with open(outputfile, 'wb') as outfile:
        ## Iterate over the paths of input files 
        for i,inpath in enumerate(inpaths):
            ## If the path is real and has a sizes greater than zero 
            if exists(inpath) and getsize(inpath): 

                ## Open the input file for reading 
                with open(inpath, 'rb') as infile:
                    ## Remove header, by reading in first line
                    if i and removeheader:
                        infile.readline()  
                    ## Then block copy the rest of file from input to output without parsing
                    shutil.copyfileobj(infile, outfile)
    ## print tolog
    print('Finished concatenation of %s input files to %s.'%(len(inpaths),outputfile))
## End of file 