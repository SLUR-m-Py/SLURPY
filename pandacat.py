#!/usr/bin/env python
"""
Â© 2023. Triad National Security, LLC. All rights reserved.
This program was produced under U.S. Government contract 89233218CNA000001 for Los Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC for the U.S. Department of Energy/National Nuclear Security Administration. 
All rights in the program are reserved by Triad National Security, LLC, and the U.S. Department of Energy/National Nuclear Security Administration. 
The Government is granted for itself and others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this material to reproduce, prepare derivative works, distribute copies to the public, perform publicly and display publicly, and to permit others to do so.
"""
## --------------------------- v 1.0.0 ---------------------------- ## 
##   PANDA CAT (Concatonate pandas dataframe in python) 
## ---------------------------------------------------------------- ##
"""
Written by:

Cullen Roth, Ph.D.

Postdoctoral Research Associate
Genomics and Bioanalytics (B-GEN)
Los Alamos National Laboratory
Los Alamos, NM 87545
croth@lanl.gov
"""
## -------------------------------------------------- MOD LOADING ----------------------------------------------- ## 
## Load in reset ftn and file exists ftn 
from defaults import fileexists, reset
## Bring in hutil
import shutil, argparse
## Load in slurpy dir 
from parameters import slurpydir

## Ftn for calling pandacat for concatonating
def pandacat(infiles:list, outfile:str, rmheader=False, sortpaths=False) -> tuple:
    """Formats a command to merge hic file from pandas dataframe."""
    ## Set the skip head and soritng flags
    skiphead = ' --skipheader ' if rmheader else ''
    sorting  = ' --sort ' if sortpaths else ''
    ## Return the formated commands
    return [f'{slurpydir}/pandacat.py -i {" ".join(infiles)} -o {outfile}{skiphead}{sorting}\n']#, f'{scriptsdir}/myecho.py Finished concatenating files into file: {outfile} {report}\n']

## Concatonation ftn 
def concatonation(inputs:list,output:str,noheader:bool) -> bool:
    ## Open the output file for wiritng (only once?)
    with open(output, 'wb') as outfile:
        ## Iterate over the paths of input files 
        for i,inpath in enumerate(inputs):
            ## Open the input file for reading 
            with open(inpath, 'rb') as infile:
                ## Remove header, by reading in first line,
                if i: ## of every file past the first (zeroth)
                    infile.readline()
                ## if we don't want a header and its our first file
                elif noheader and (not i):
                    infile.readline()  
                else: ## Otherwise do nothing 
                    pass 
                ## Then block copy the rest of file from input to output without parsing
                shutil.copyfileobj(infile, outfile)
                ## Close the infile
                infile.close()
        ## close the outfile 
        outfile.close()
    ## Return the output file path boolean 
    return fileexists(output)

## Set the script sescription
pandadesc = "Concatonates a series of input pandas dataframes as text files (ingnoring header on all but first)."

## Set help message
i_help = "Input wild card path (or paths) to csv,txt, or bedpe files to be combined."
o_help = "Output path of combined file generated by this script."
R_help = "Boolean flag to skipper header of file in all but first file."
B_help = "Boolean flag to sort the input file names from  a wild card."

## Ftn for parsing arguments
def parse_args():
    ## Make the parse
    parser = argparse.ArgumentParser(description = pandadesc)
    ## Add the required arguments
    parser.add_argument("-i", dest="I", nargs='+', required=True,  help=i_help, metavar='./path/to/input.txt')
    parser.add_argument("-o", dest="O", type=str,  required=True,  help=o_help, metavar="./path/to/combined.out.txt")
    ## Add boolean vars
    parser.add_argument("--skipheader", dest="R",  help = R_help,  action = 'store_true')
    parser.add_argument("--sort",       dest="S",  help = B_help,  action = 'store_true')
    ## Set the paresed values as inputs
    return parser.parse_args()

## ------------------------------------------------------ BODY of MAIN EXECUTABLE --------------------------------------------------------- ##
## If the script is called 
if __name__ == "__main__":
    ## Set the paresed values as inputs
    inputs = parse_args()

    ## Set inputs 
    inpaths      = inputs.I     ## Input text files 
    outputfile   = inputs.O     ## Output files
    removeheader = inputs.R     ## Removeing the header
    sorting      = inputs.S     ## Flag to sort 

    ## Make sure we have files
    assert len(inpaths), "ERROR: No files were passed. Failed to generate %s!"%outputfile

    ## Modify the input paths for backwards compatibality, make sure only a str was passed with wild-card symbole in it. 
    if (len(inpaths) == 1) and ('*' in inpaths[0]):
        ## Bring in glob from glob 
        from glob import glob 
        ## bring in paths 
        inpaths = glob(inpaths[0])
        ## Check our paths
        assert len(inpaths), "ERROR: No files could be gathered with input wildcard: %s"%inpaths[0]

    ## Sort the input files 
    inpaths = sorted(inpaths) if sorting else inpaths

    ## Remove the previous output file it is exists
    k = reset([outputfile])

    ## Check that we have actual data files 
    inpaths = [f for f in inpaths if fileexists(f)]

    ## Concatonate the input paths 
    assert (concatonation(inpaths,outputfile,removeheader) if len(inpaths) else True), "ERROR: Unable to concatonate files!"
                    
    ## print to log
    print('Finished concatenation of %s input files to %s.'%(len(inpaths),outputfile))
## End of file 