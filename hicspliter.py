#!/usr/bin/env python
#################################################
## Hi-C SPLITER - splits a bam file (v 4.1.0)  ##
#################################################
"""
Written by:

Cullen Roth, Ph.D.

Postdoctoral Research Associate
Genomics and Bioanalytics (B-GEN)
Los Alamos National Laboratory
Los Alamos, NM 87545
croth@lanl.gov
"""
## Set version
version = '4.1.0'

## Set the description
split_desc = "Hi-C SPLITER (v %s): Splits an input bam file from a Hi-C experiment on mapped, placed, unmapped, and mtDNA read sets."%version

## Bring in default help message
from slurpy import M_help, mito_contig, fileexists, not_sam_err

## Load in pysam 
#import pysam

## Bring in pandas dataframe
import pandas as pd 

## Load in ftns from bio-analytics
from pysamtools import loadbam, getalignment, checksam, bamtobedpe, writetofile, outnames

## Bring in os ftns
from os import remove

## Set error messages
miss_align_err  = "ERROR: missing alignments!" 
pass_align_err  = "ERROR: Failed to properly pass alignments."
write_read_err  = "ERROR: Unable to write %s read names to file."
miss_match_err  = "ERROR: The reads are not pairs! This represents a critical error!"
critical_err    = "ERROR: Incountered a crticial unexpected error!"

## Set help messages
help_bam        = "Path to input bam file from Hi-C experiment to split on genomic regions."
help_split      = "The split size (int) used to seperate and input bam file."
help_ix         = "The split index (int) used to decide the chunk of reads to work on."
help_rp         = "The path to readnames stored within input bam file."

## Check the versions of samtools
assert checksam(), not_sam_err

## Set ftn for making a list of a set
def listset(x):
    """Returns a list made of the set of the input x."""
    ## Return the list set
    return list(set(x))

## Ftn for setting splits of input list y
def setsplit(y,s):
    """Returns splits of input list y given size s. """
    ## Parse the chunks of y
    return [y[x:x+s] for x in range(0, len(y), s)]

## Ftn for making table 
def recordstable(pyobj, colnames = ['Readname','Isread1','Unmapped','Chromosome','Mapq']):
    """Generates a table of basic information from pyrces, including query name, is read one, and if pairs are unmapped."""
    ## Returns a dataframe with mapping info per record
    recs_out, row_in = [], []
    for r in pyobj: ## Iterate thru the records
        ## Append to rows
        row_in.append((r.query_name,r.is_read1,r.is_unmapped,r.reference_name,int(r.mapq)))
        ## Append the record
        recs_out.append(r)
    ## Return the records and dataframe
    return recs_out, pd.DataFrame(row_in, columns=colnames)

## Ftn for determining if an aligment is chimeric
def ischimeric(recs):
    """Returns a one or a zero if length of input recs is greater than one."""
    ## Return a zero or 1 if more than one rect
    return 1 if len(recs) > 1 else 0

## Ftn for retriving pairs or recrods 
def getpairs(pyrecs,ix1,ix2):
    """Return records from list by index(s)."""
    ## return records by index
    return [pyrecs[i] for i in ix1], [pyrecs[j] for j in ix2]

## ------------------------------------------------------------- MAIN EXECUTABLE ------------------------------------------------------------------- ##
## if the script is envoked
if __name__ == "__main__":
    ## Import argparse and set parser
    import argparse

    ## Make the parse
    parser = argparse.ArgumentParser(description = split_desc)

    ## Add the required arguments
    parser.add_argument("-b", "--bam",          dest="B", type=str, required=True,  help=help_bam, metavar='./path/to/bam')

    ## Set the optional variables
    parser.add_argument("-M", "--mitochondria", dest="M", type=str, required=False, help=M_help,   metavar=mito_contig, default=mito_contig)

    ## set the paresed values as inputs
    inputs = parser.parse_args()

    ## Set input variables, input bam file path, mito contig name, number of threads, verbosity, and keeping vars
    inbampath, mito = inputs.B, inputs.M 

    ## Format the name of output files generated by this script 
    outbam_name, placedfile_txtname, mitofile_txtname, unmapped_txtname, output_bedfile = outnames(inbampath,mito)

    ## Remove privous file from above list of output 
    for previous_file in [outbam_name, placedfile_txtname, mitofile_txtname, unmapped_txtname, output_bedfile]:
        remove(previous_file) if fileexists(previous_file) else None 

    ## Load in the bam file 
    bamfile = loadbam(inbampath)

    ## Load in py recs and make a data tabel 
    records, rectable = recordstable(bamfile)

    ## Make a set of all read names
    allreads = set(rectable.Readname)

    ## Find mito mapping reads and make a set of them 
    mitocondrial = set(rectable[(rectable.Chromosome==mito)].Readname)

    ## Gather read1 and read2 read names without mito mapping reads
    read1, read2 = rectable[(rectable.Isread1) & ~(rectable.Readname.isin(mitocondrial))], rectable[~(rectable.Isread1) & ~(rectable.Readname.isin(mitocondrial))]

    ## Gather sets of unmapped r1 and r2
    unmapped_r1, unmapped_r2  = set(read1[(read1.Unmapped)].Readname), set(read2[(read2.Unmapped)].Readname)

    ## Gather intersection were both reads unmapped
    unmapped = unmapped_r1 & unmapped_r2

    ## Gather placed reads
    placed = (unmapped_r1 | unmapped_r2) - unmapped

    ## Segregate the reads to parse 
    reads_to_parse = allreads - (unmapped | placed | mitocondrial)

    ## Make a dataframe of parseable reads
    to_parse = rectable[(rectable.Readname.isin(reads_to_parse))]

    ## Check our work 
    assert ~(mito in to_parse.Chromosome.unique()), critical_err
    assert ~(to_parse.Unmapped.sum()), critical_err

    ## Initilize bam file object to write the alignments to and initilize count
    #alignments, n_alignments  = pysam.AlignmentFile(outbam_name, 'wb', template=bamfile), 0
    n_alignments = 0

    ## Group by readname of mapped parsabel reads
    for r,df in to_parse.groupby('Readname'):
        
        ## Gather index of reads 1 and 2
        r1_ix, r2_ix = df[(df.Isread1)].index.tolist(), df[~(df.Isread1)].index.tolist()
        ## Determine if these reads are chimeric
        is1_chimeric, is2_chimeric = ischimeric(r1_ix), ischimeric(r2_ix)
        ## Gather the pairs of records 
        recs_1, recs_2 = getpairs(records,r1_ix,r2_ix)
        ## Get the correct alignment
        read_1, read_2 = getalignment(recs_1), getalignment(recs_2)
            
        ## Check our work
        assert (read_1.qname == read_2.qname), miss_match_err

        ## Write aligment bam 
        #[alignments.write(rec) for rec in [read_1,read_2]]
        ## format line for bam to bed
        newline = bamtobedpe(read_1,read_2) + ' %s %s %s %s\n'%(is1_chimeric,is2_chimeric,len(recs_1),len(recs_2))
        
        ## Append to file
        writetofile(output_bedfile, [newline], debug=False, mode='a')

        ## Add count to mitochondria
        n_alignments += 1

    ## close the bam files
    #alignments.close()

    ## Check our work
    assert int(n_alignments) == len(reads_to_parse), pass_align_err

    ## Write the unmapped and placed sets to file
    assert fileexists(writetofile(unmapped_txtname,   [s+'\n' for s in unmapped],     debug=False)), write_read_err%'unmapped'
    assert fileexists(writetofile(placedfile_txtname, [s+'\n' for s in placed],       debug=False)), write_read_err%'placed'
    assert fileexists(writetofile(mitofile_txtname,   [s+'\n' for s in mitocondrial], debug=False)), write_read_err%mito
## End of file 